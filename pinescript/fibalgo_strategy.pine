//@version=6
strategy("FibAlgo Strategy", overlay=true, default_qty_type=strategy.fixed, default_qty_value=1, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.1, slippage=1, pyramiding=2, max_lines_count=500, max_labels_count=500, max_boxes_count=50)

// =============================================================================
// INPUTS
// =============================================================================

autoPivot      = input.bool(true, "Auto Pivot (by timeframe)", group="Swing Detection")
pivotLen       = input.int(5, "Manual Pivot Length", minval=2, maxval=50, group="Swing Detection", tooltip="Only used when Auto Pivot is off")

maxLossDollars = input.float(100, "Max Loss Per Trade ($)", minval=10, step=10, group="Risk Management")
atrLen         = input.int(14, "ATR Length", minval=1, group="Risk Management")
atrMult        = input.float(1.5, "ATR SL Multiplier", minval=0.5, maxval=5.0, step=0.1, group="Risk Management", tooltip="SL = ATR * this value from entry. Caps the max SL distance.")
minRR          = input.float(1.0, "Min R:R", minval=0.5, maxval=5.0, step=0.1, group="Risk Management")
minConv        = input.float(60, "Min Conviction %", minval=30, maxval=90, step=5, group="Risk Management", tooltip="Only enter when conviction score is above this threshold")
fibProximity   = input.float(0.5, "Fib Proximity (ATR)", minval=0.1, maxval=2.0, step=0.1, group="Risk Management", tooltip="How close price must be to a fib level (in ATR units)")

exitR1         = input.float(1.25, "1st Exit (R)", minval=0.5, maxval=5.0, step=0.25, group="Exit Strategy", tooltip="Sell 1st partial, move SL to BE, add pyramid shares")
exitR2         = input.float(1.75, "2nd Exit (R)", minval=0.5, maxval=5.0, step=0.25, group="Exit Strategy")
exitR3         = input.float(2.25, "3rd Exit (R)", minval=1.0, maxval=10.0, step=0.25, group="Exit Strategy")
exitPct1       = input.int(25, "1st Exit %", minval=10, maxval=50, step=5, group="Exit Strategy")
exitPct2       = input.int(25, "2nd Exit %", minval=10, maxval=50, step=5, group="Exit Strategy")
exitPct3       = input.int(20, "3rd Exit %", minval=10, maxval=50, step=5, group="Exit Strategy", tooltip="Remainder (30%) trails with SMA 50")
pyramidPct     = input.int(30, "Pyramid Add %", minval=10, maxval=50, step=5, group="Exit Strategy", tooltip="% of original qty to add when SL moves to BE")
useEMABounce   = input.bool(true, "EMA 21 Bounce Re-entry", group="Entry Strategy", tooltip="Allow re-entry when price bounces off EMA 21 in trend direction")

emaFastLen     = input.int(21, "EMA 21 (Fast)", minval=5, group="Trend")
sma50Len       = input.int(50, "SMA 50", minval=10, group="Trend")
sma150Len      = input.int(150, "SMA 150 (Direction)", minval=50, group="Trend")
sectorETF      = input.symbol("XLK", "Sector ETF", group="Trend", tooltip="Sector ETF for extra conviction (e.g., XLF for banks, XLK for tech, XLE for energy)")

showFibs       = input.bool(true, "Show Fib Lines", group="Display")
showHTF        = input.bool(false, "Show Higher TF Fibs", group="Display")
showDashboard  = input.bool(true, "Show Dashboard", group="Display")
showSignals    = input.bool(true, "Show BUY/SELL Labels", group="Display")
showMAs        = input.bool(false, "Show MA Lines", group="Display")
showAVWAP      = input.bool(true, "Show AVWAP 52WH", group="Display")
dashSize       = input.string("large", "Dashboard Text Size", options=["tiny", "small", "normal", "large"], group="Display")

// =============================================================================
// CORE CALCULATIONS
// =============================================================================

atrVal   = ta.atr(atrLen)
ema21    = ta.ema(close, emaFastLen)
sma50    = ta.sma(close, sma50Len)
sma150   = ta.sma(close, sma150Len)
rsiVal   = ta.rsi(close, 14)

adxLen      = input.int(14, "ADX Length", minval=5, group="Filters")
adxThresh   = input.float(25.0, "ADX Min Threshold", minval=15, maxval=50, step=1, group="Filters", tooltip="ADX > this = trending market. Below = choppy, no trades.")

// ADX calculation (Pine Script v6 — manual DMI)
float trVal    = ta.tr(true)
float plusDM   = high - high[1] > low[1] - low ? math.max(high - high[1], 0) : 0
float minusDM  = low[1] - low > high - high[1] ? math.max(low[1] - low, 0) : 0
float smoothTR = ta.rma(trVal, adxLen)
float plusDI    = smoothTR > 0 ? 100 * ta.rma(plusDM, adxLen) / smoothTR : 0
float minusDI   = smoothTR > 0 ? 100 * ta.rma(minusDM, adxLen) / smoothTR : 0
float diSum    = plusDI + minusDI
float dx       = diSum > 0 ? 100 * math.abs(plusDI - minusDI) / diSum : 0
float adxVal   = ta.rma(dx, adxLen)

bool isTrending = adxVal > adxThresh

// Sector ETF trend
sectorClose  = request.security(sectorETF, timeframe.period, close, barmerge.gaps_off, barmerge.lookahead_off)
sectorSMA150 = request.security(sectorETF, timeframe.period, ta.sma(close, 150), barmerge.gaps_off, barmerge.lookahead_off)
bool sectorBull = not na(sectorClose) and not na(sectorSMA150) and sectorClose > sectorSMA150
bool sectorBear = not na(sectorClose) and not na(sectorSMA150) and sectorClose < sectorSMA150

plot(showMAs ? ema21 : na, "EMA 21", color.new(#00BCD4, 0), 2)
plot(showMAs ? sma50 : na, "SMA 50", color.new(#FF5722, 0), 2)
plot(showMAs ? sma150 : na, "SMA 150", color.new(#FFEB3B, 40), 1)

// Auto pivot: lower TF = higher pivot to filter noise
autoLen = timeframe.isintraday ?
     (timeframe.multiplier <= 5 ? 10 :
      timeframe.multiplier <= 15 ? 8 :
      timeframe.multiplier <= 60 ? 6 :
      timeframe.multiplier <= 240 ? 5 : 4) :
     (timeframe.period == "D" ? 3 :
      timeframe.period == "W" ? 2 : 2)

actualPivotLen = autoPivot ? autoLen : pivotLen

// =============================================================================
// AVWAP FROM 52-WEEK HIGH
// =============================================================================

daily52WH = request.security(syminfo.tickerid, "D", ta.highest(high, 252), barmerge.gaps_off, barmerge.lookahead_off)

var float avwapPrev52 = na
var float cumVol      = 0.0
var float cumVolPrice = 0.0

bool new52WH = not na(daily52WH) and (na(avwapPrev52) or daily52WH > avwapPrev52)

if new52WH
    avwapPrev52 := daily52WH
    cumVol      := volume
    cumVolPrice := hlc3 * volume
else
    cumVol      += volume
    cumVolPrice += hlc3 * volume

float avwap52 = cumVol > 0 ? cumVolPrice / cumVol : na
plot(showAVWAP ? avwap52 : na, "AVWAP 52WH", color.new(color.purple, 30), 1, plot.style_line)

bool avwapGoldenX = not na(avwap52) and not na(sma50) and ta.crossover(sma50, avwap52)
plotchar(showAVWAP and avwapGoldenX ? true : false, "SMA50 x AVWAP", "★", location.belowbar, color.new(color.yellow, 0), size=size.normal)

// =============================================================================
// RELATIVE STRENGTH
// =============================================================================

rsRank = ta.percentrank(close, 252)

// =============================================================================
// SWING DETECTION
// =============================================================================

pivotHigh = ta.pivothigh(high, actualPivotLen, actualPivotLen)
pivotLow  = ta.pivotlow(low, actualPivotLen, actualPivotLen)

var float swHigh    = na
var int   swHighBar = na
var float swLow     = na
var int   swLowBar  = na
var bool  newSwing  = false

newSwing := false

if not na(pivotHigh)
    swHigh    := pivotHigh
    swHighBar := bar_index - actualPivotLen
    newSwing  := true

if not na(pivotLow)
    swLow    := pivotLow
    swLowBar := bar_index - actualPivotLen
    newSwing := true

// =============================================================================
// HIGHER TIMEFRAME FIBS (context levels)
// =============================================================================

htf = timeframe.isintraday ? "D" : "W"
htfHigh    = request.security(syminfo.tickerid, htf, ta.highest(high, 20), barmerge.gaps_off, barmerge.lookahead_off)
htfLow     = request.security(syminfo.tickerid, htf, ta.lowest(low, 20), barmerge.gaps_off, barmerge.lookahead_off)
htfSMA150  = request.security(syminfo.tickerid, htf, ta.sma(close, 150), barmerge.gaps_off, barmerge.lookahead_off)

bool htfValid = not na(htfHigh) and not na(htfLow) and htfHigh > htfLow
float htfRange = htfValid ? htfHigh - htfLow : na

float htf382 = htfValid ? htfHigh - htfRange * 0.382 : na
float htf500 = htfValid ? htfHigh - htfRange * 0.500 : na
float htf618 = htfValid ? htfHigh - htfRange * 0.618 : na

// =============================================================================
// TREND DIRECTION — SMA 150 for direction, rest is conviction
// =============================================================================

bool aboveSMA150 = not na(sma150) and close > sma150
bool belowSMA150 = not na(sma150) and close < sma150

// Entry direction based on SMA 150 only
bool isBull = aboveSMA150
bool isBear = belowSMA150

// HTF trend alignment
bool htfBull = not na(htfSMA150) and close > htfSMA150
bool htfBear = not na(htfSMA150) and close < htfSMA150

// =============================================================================
// FIBONACCI LEVELS (current timeframe)
// =============================================================================

bool hasSwings = not na(swHigh) and not na(swLow) and swHigh > swLow
float swRange  = hasSwings ? swHigh - swLow : na

float fib236 = na, float fib382 = na, float fib500 = na
float fib618 = na, float fib786 = na
float ext127 = na, float ext162 = na

if hasSwings
    fib236 := swHigh - swRange * 0.236
    fib382 := swHigh - swRange * 0.382
    fib500 := swHigh - swRange * 0.500
    fib618 := swHigh - swRange * 0.618
    fib786 := swHigh - swRange * 0.786
    ext127 := swLow + swRange * 1.272
    ext162 := swLow + swRange * 1.618

float atrPct = not na(atrVal) and close > 0 ? (atrVal / close) * 100 : na

// =============================================================================
// CANDLESTICK PATTERNS
// =============================================================================

float bodySize    = math.abs(close - open)
float upperWick   = high - math.max(close, open)
float lowerWick   = math.min(close, open) - low
float candleRange = high - low
float bodyPct     = candleRange > 0 ? bodySize / candleRange : 0

bool isDoji          = bodyPct < 0.1 and candleRange > 0
bool isDragonflyDoji = isDoji and lowerWick > candleRange * 0.6 and upperWick < candleRange * 0.1
bool isGravestoneDoji = isDoji and upperWick > candleRange * 0.6 and lowerWick < candleRange * 0.1
bool isBullMarubozu  = close > open and bodyPct > 0.8
bool isBearMarubozu  = close < open and bodyPct > 0.8
bool isHammer        = close >= open and bodySize > 0 and lowerWick >= bodySize * 2 and upperWick <= bodySize * 0.5
bool isShootingStar  = close <= open and bodySize > 0 and upperWick >= bodySize * 2 and lowerWick <= bodySize * 0.5
bool isBullEngulfing = close > open and close[1] < open[1] and close > open[1] and open <= close[1]
bool isBearEngulfing = close < open and close[1] > open[1] and close < open[1] and open >= close[1]
bool isInsideBar     = high <= high[1] and low >= low[1]

bool bullConfirm = close > open or isHammer or isDragonflyDoji or isBullMarubozu or isBullEngulfing or (isInsideBar and close >= open)
bool bearConfirm = close < open or isShootingStar or isGravestoneDoji or isBearMarubozu or isBearEngulfing or (isInsideBar and close <= open)

string patternName = isBullMarubozu ? "Bull Marubozu" : isBearMarubozu ? "Bear Marubozu" : isBullEngulfing ? "Bull Engulfing" : isBearEngulfing ? "Bear Engulfing" : isHammer ? "Hammer" : isShootingStar ? "Shooting Star" : isDragonflyDoji ? "Dragonfly Doji" : isGravestoneDoji ? "Gravestone Doji" : isDoji ? "Doji" : isInsideBar ? "Inside Bar" : close > open ? "Bullish" : close < open ? "Bearish" : "Neutral"

// =============================================================================
// RSI DIVERGENCE DETECTION
// =============================================================================

// Bullish divergence: price makes lower low, RSI makes higher low (at fib support)
float rsiLow1  = ta.lowest(rsiVal, actualPivotLen)
float rsiLow2  = ta.lowest(rsiVal, actualPivotLen)[actualPivotLen]
float priceLow1 = ta.lowest(low, actualPivotLen)
float priceLow2 = ta.lowest(low, actualPivotLen)[actualPivotLen]
bool bullDivergence = priceLow1 < priceLow2 and rsiLow1 > rsiLow2

// Bearish divergence: price makes higher high, RSI makes lower high (at fib resistance)
float rsiHigh1  = ta.highest(rsiVal, actualPivotLen)
float rsiHigh2  = ta.highest(rsiVal, actualPivotLen)[actualPivotLen]
float priceHigh1 = ta.highest(high, actualPivotLen)
float priceHigh2 = ta.highest(high, actualPivotLen)[actualPivotLen]
bool bearDivergence = priceHigh1 > priceHigh2 and rsiHigh1 < rsiHigh2

// =============================================================================
// SL / TP — ATR-CAPPED (no more SL 50% away)
// =============================================================================

// ATR-based SL (always reasonable distance)
float atrSLdist = nz(atrVal) * atrMult
float longSLatr  = close - atrSLdist
float shortSLatr = close + atrSLdist

// Swing-based SL (traditional)
float longSLswing  = hasSwings ? swLow - nz(atrVal) * 0.5 : na
float shortSLswing = hasSwings ? swHigh + nz(atrVal) * 0.5 : na

// Use the TIGHTER of swing-based and ATR-based (whichever is closer to price)
float longSL  = not na(longSLswing) and longSLswing > longSLatr and longSLswing < close ? longSLswing : longSLatr < close ? longSLatr : na
float shortSL = not na(shortSLswing) and shortSLswing < shortSLatr and shortSLswing > close ? shortSLswing : shortSLatr > close ? shortSLatr : na

// TP estimates for R:R display (actual exit uses EMA 21 trailing)
float longTP1  = hasSwings and swHigh > close ? swHigh : not na(htf382) and htf382 > close ? htf382 : na
float longTP2  = not na(ext127) and ext127 > close ? ext127 : not na(ext162) and ext162 > close ? ext162 : not na(htfHigh) and htfHigh > close ? htfHigh : na
float shortTP1 = hasSwings and swLow < close ? swLow : not na(htf618) and htf618 < close ? htf618 : na
float shortTP2 = hasSwings and (swLow - swRange * 0.272) < close ? swLow - swRange * 0.272 : not na(htfLow) and htfLow < close ? htfLow : na

// =============================================================================
// ENTRY LOGIC — Near ANY key fib level + SMA 150 direction + candle pattern
// =============================================================================

float fibDist = nz(atrVal) * fibProximity
float goldenDist = fibDist * 1.5  // 61.8% gets wider zone (golden pocket)

// Check if price is near any key fib level (current TF or HTF)
bool nearFib382 = hasSwings and math.abs(close - fib382) < fibDist
bool nearFib500 = hasSwings and math.abs(close - fib500) < fibDist
bool nearFib618 = hasSwings and math.abs(close - fib618) < goldenDist
bool nearHTF382 = not na(htf382) and math.abs(close - htf382) < fibDist
bool nearHTF500 = not na(htf500) and math.abs(close - htf500) < fibDist
bool nearHTF618 = not na(htf618) and math.abs(close - htf618) < goldenDist

bool nearAnyFib = nearFib500 or nearFib618 or nearHTF500 or nearHTF618

// Long: above SMA 150 + HTF aligned + near fib support + bullish candle + trending market
bool longGZ = nearAnyFib and isBull and htfBull and bullConfirm and not na(longSL) and isTrending and strategy.position_size == 0

// Short: below SMA 150 + HTF aligned + near fib resistance + bearish candle + trending market
bool shortGZ = nearAnyFib and isBear and htfBear and bearConfirm and not na(shortSL) and isTrending and strategy.position_size == 0

// EMA 21 bounce re-entry (trend continuation)
bool ema21BounceLong  = useEMABounce and strategy.position_size == 0 and isBull and htfBull and isTrending and low <= ema21 and close > ema21 and bullConfirm and not na(longSL)
bool ema21BounceShort = useEMABounce and strategy.position_size == 0 and isBear and htfBear and isTrending and high >= ema21 and close < ema21 and bearConfirm and not na(shortSL)

// =============================================================================
// POSITION SIZING & R:R
// =============================================================================

float longQty = na, float longRR = na
float shortQty = na, float shortRR = na

if (longGZ or ema21BounceLong) and not na(longSL)
    float sd = close - longSL
    if sd > 0
        float r1 = not na(longTP1) ? (longTP1 - close) : 0
        float r2 = not na(longTP2) ? (longTP2 - close) : r1
        longRR  := (0.5 * r1 + 0.5 * r2) / sd
        longQty := math.max(1, math.floor(maxLossDollars / sd))

if (shortGZ or ema21BounceShort) and not na(shortSL)
    float sd = shortSL - close
    if sd > 0
        float r1 = not na(shortTP1) ? (close - shortTP1) : 0
        float r2 = not na(shortTP2) ? (close - shortTP2) : r1
        shortRR  := (0.5 * r1 + 0.5 * r2) / sd
        shortQty := math.max(1, math.floor(maxLossDollars / sd))

// =============================================================================
// CONVICTION SCORING (0-100%)
// =============================================================================

float bullPts = 0.0, float bearPts = 0.0

bullPts += not na(sma150) and close > sma150 ? 15 : 0
bearPts += not na(sma150) and close < sma150 ? 15 : 0
bullPts += ema21 > sma50 ? 10 : 0
bearPts += ema21 < sma50 ? 10 : 0
bullPts += close > ema21 ? 10 : 0
bearPts += close < ema21 ? 10 : 0
bullPts += close > sma50 ? 10 : 0
bearPts += close < sma50 ? 10 : 0
bullPts += rsiVal > 50 and rsiVal < 70 ? 5 : 0
bearPts += rsiVal < 50 and rsiVal > 30 ? 5 : 0
bullPts += nearAnyFib and isBull ? 10 : 0
bearPts += nearAnyFib and isBear ? 10 : 0
bullPts += not na(avwap52) and close > avwap52 ? 10 : 0
bearPts += not na(avwap52) and close < avwap52 ? 10 : 0
bullPts += bullConfirm ? 10 : 0
bearPts += bearConfirm ? 10 : 0
bullPts += isTrending ? 10 : 0
bearPts += isTrending ? 10 : 0
bullPts += bullDivergence ? 10 : 0
bearPts += bearDivergence ? 10 : 0
bullPts += sectorBull ? 10 : 0
bearPts += sectorBear ? 10 : 0

float convPct = math.max(bullPts, bearPts)
string convDir = bullPts > bearPts ? "Bullish" : bullPts < bearPts ? "Bearish" : "Neutral"
color convCol = bullPts > bearPts ? color.green : bullPts < bearPts ? color.red : color.gray

// =============================================================================
// STRATEGY EXECUTION
// =============================================================================

bool goLong  = (longGZ or ema21BounceLong) and not na(longRR) and longRR >= minRR and bullPts >= minConv
bool goShort = (shortGZ or ema21BounceShort) and not na(shortRR) and shortRR >= minRR and bearPts >= minConv

// Track R-multiple exit state — original position
var float entryPrice  = na
var float initialSL   = na
var float riskDist    = na
var float origQty     = na
var bool  hitR1       = false
var bool  hitR2       = false
var bool  hitR3       = false
// Track pyramid add-on
var bool  pyramidDone = false
var float pyEntry     = na
var float pyRisk      = na
var float pyQty       = na
var bool  pyHitR2     = false  // pyramid's 1.75R
var bool  pyHitR3     = false  // pyramid's 2.25R

if goLong
    strategy.entry("Long", strategy.long, qty=longQty)
    entryPrice  := close
    initialSL   := longSL
    riskDist    := close - longSL
    origQty     := longQty
    hitR1       := false
    hitR2       := false
    hitR3       := false
    pyramidDone := false
    pyHitR2     := false
    pyHitR3     := false
    strategy.exit("LSL", "Long", stop=longSL)

if goShort
    strategy.entry("Short", strategy.short, qty=shortQty)
    entryPrice  := close
    initialSL   := shortSL
    riskDist    := shortSL - close
    origQty     := shortQty
    hitR1       := false
    hitR2       := false
    hitR3       := false
    pyramidDone := false
    pyHitR2     := false
    pyHitR3     := false
    strategy.exit("SSL", "Short", stop=shortSL)

// --- R-Multiple Scaling: Longs ---
if strategy.position_size > 0 and not na(entryPrice) and not na(riskDist) and riskDist > 0
    float curProfit = close - entryPrice

    // +1.25R: sell 25%, move SL to BE, pyramid 30% more shares
    if not hitR1 and curProfit >= riskDist * exitR1
        hitR1 := true
        float qty1 = math.max(1, math.floor(origQty * exitPct1 / 100.0))
        strategy.order("L+R1", strategy.short, qty=qty1, comment=str.tostring(exitR1, "#.##") + "R")
        strategy.exit("LSL", "Long", stop=entryPrice)
        // Pyramid: add 30% of original qty
        if not pyramidDone
            pyramidDone := true
            pyQty   := math.max(1, math.floor(origQty * pyramidPct / 100.0))
            pyEntry := close
            pyRisk  := close - entryPrice  // SL is at BE (entry), so risk = current - entry
            strategy.entry("Long", strategy.long, qty=pyQty)

    // +1.75R: sell 25% of original
    if not hitR2 and curProfit >= riskDist * exitR2
        hitR2 := true
        float qty2 = math.max(1, math.floor(origQty * exitPct2 / 100.0))
        strategy.order("L+R2", strategy.short, qty=qty2, comment=str.tostring(exitR2, "#.##") + "R")
        strategy.exit("LSL", "Long", stop=entryPrice + riskDist * 0.5)

    // +2.25R: sell 20% of original
    if not hitR3 and curProfit >= riskDist * exitR3
        hitR3 := true
        float qty3 = math.max(1, math.floor(origQty * exitPct3 / 100.0))
        strategy.order("L+R3", strategy.short, qty=qty3, comment=str.tostring(exitR3, "#.##") + "R")
        strategy.exit("LSL", "Long", stop=entryPrice + riskDist)

    // Pyramid partials (based on pyramid's own R)
    if pyramidDone and not na(pyEntry) and not na(pyRisk) and pyRisk > 0
        float pyProfit = close - pyEntry
        // Pyramid +1.75R: sell some pyramid shares
        if not pyHitR2 and pyProfit >= pyRisk * exitR2
            pyHitR2 := true
            float pyQ2 = math.max(1, math.floor(pyQty * exitPct2 / 100.0))
            strategy.order("LP+R2", strategy.short, qty=pyQ2, comment="Pyr " + str.tostring(exitR2, "#.##") + "R")
        // Pyramid +2.25R: sell more pyramid shares
        if not pyHitR3 and pyProfit >= pyRisk * exitR3
            pyHitR3 := true
            float pyQ3 = math.max(1, math.floor(pyQty * exitPct3 / 100.0))
            strategy.order("LP+R3", strategy.short, qty=pyQ3, comment="Pyr " + str.tostring(exitR3, "#.##") + "R")

    // Runner: close below SMA 50 = exit everything remaining
    if hitR3 and close < sma50
        strategy.close("Long", comment="Runner closed under SMA50")

// --- R-Multiple Scaling: Shorts ---
if strategy.position_size < 0 and not na(entryPrice) and not na(riskDist) and riskDist > 0
    float curProfit = entryPrice - close

    // +1.25R: sell 25%, move SL to BE, pyramid 30% more shares
    if not hitR1 and curProfit >= riskDist * exitR1
        hitR1 := true
        float qty1 = math.max(1, math.floor(origQty * exitPct1 / 100.0))
        strategy.order("S+R1", strategy.long, qty=qty1, comment=str.tostring(exitR1, "#.##") + "R")
        strategy.exit("SSL", "Short", stop=entryPrice)
        if not pyramidDone
            pyramidDone := true
            pyQty   := math.max(1, math.floor(origQty * pyramidPct / 100.0))
            pyEntry := close
            pyRisk  := entryPrice - close
            strategy.entry("Short", strategy.short, qty=pyQty)

    // +1.75R: sell 25% of original
    if not hitR2 and curProfit >= riskDist * exitR2
        hitR2 := true
        float qty2 = math.max(1, math.floor(origQty * exitPct2 / 100.0))
        strategy.order("S+R2", strategy.long, qty=qty2, comment=str.tostring(exitR2, "#.##") + "R")
        strategy.exit("SSL", "Short", stop=entryPrice - riskDist * 0.5)

    // +2.25R: sell 20% of original
    if not hitR3 and curProfit >= riskDist * exitR3
        hitR3 := true
        float qty3 = math.max(1, math.floor(origQty * exitPct3 / 100.0))
        strategy.order("S+R3", strategy.long, qty=qty3, comment=str.tostring(exitR3, "#.##") + "R")
        strategy.exit("SSL", "Short", stop=entryPrice - riskDist)

    // Pyramid partials (based on pyramid's own R)
    if pyramidDone and not na(pyEntry) and not na(pyRisk) and pyRisk > 0
        float pyProfit = pyEntry - close
        if not pyHitR2 and pyProfit >= pyRisk * exitR2
            pyHitR2 := true
            float pyQ2 = math.max(1, math.floor(pyQty * exitPct2 / 100.0))
            strategy.order("SP+R2", strategy.long, qty=pyQ2, comment="Pyr " + str.tostring(exitR2, "#.##") + "R")
        if not pyHitR3 and pyProfit >= pyRisk * exitR3
            pyHitR3 := true
            float pyQ3 = math.max(1, math.floor(pyQty * exitPct3 / 100.0))
            strategy.order("SP+R3", strategy.long, qty=pyQ3, comment="Pyr " + str.tostring(exitR3, "#.##") + "R")

    // Runner: close above SMA 50 = exit everything remaining
    if hitR3 and close > sma50
        strategy.close("Short", comment="Runner closed above SMA50")

// =============================================================================
// VISUALS — FIB LINES (white, clean)
// =============================================================================

var line ln236 = na, var label lb236 = na
var line ln382 = na, var label lb382 = na
var line ln500 = na, var label lb500 = na
var line ln618 = na, var label lb618 = na
var line ln786 = na, var label lb786 = na
var line lnE127 = na, var label lbE127 = na
var line lnE162 = na, var label lbE162 = na
var line lnHigh = na, var label lbHigh = na
var line lnLow  = na, var label lbLow  = na

// HTF fib lines
var line lnHTF382 = na, var label lbHTF382 = na
var line lnHTF500 = na, var label lbHTF500 = na
var line lnHTF618 = na, var label lbHTF618 = na

drawFibLine(float price, string txt, color col, int w, bool dashed) =>
    sty = dashed ? line.style_dashed : line.style_solid
    l  = line.new(bar_index - 1, price, bar_index, price, color=col, width=w, style=sty, extend=extend.both)
    lb = label.new(bar_index, price, txt + "  " + str.tostring(price, format.mintick), style=label.style_none, textcolor=col, size=size.small, xloc=xloc.bar_index)
    [l, lb]

bool redraw = newSwing or barstate.islast

if showFibs and redraw and hasSwings
    line.delete(ln236), label.delete(lb236)
    line.delete(ln382), label.delete(lb382)
    line.delete(ln500), label.delete(lb500)
    line.delete(ln618), label.delete(lb618)
    line.delete(ln786), label.delete(lb786)
    line.delete(lnE127), label.delete(lbE127)
    line.delete(lnE162), label.delete(lbE162)
    line.delete(lnHigh), label.delete(lbHigh)
    line.delete(lnLow), label.delete(lbLow)

    [lH, labH] = drawFibLine(swHigh, "High", color.new(color.white, 30), 1, false)
    lnHigh := lH, lbHigh := labH
    [lL, labL] = drawFibLine(swLow, "Low", color.new(color.white, 30), 1, false)
    lnLow := lL, lbLow := labL

    [l1, lb1] = drawFibLine(fib236, "23.6%", color.new(color.white, 60), 1, false)
    ln236 := l1, lb236 := lb1

    [l2, lb2] = drawFibLine(fib382, "38.2%", color.new(color.white, 40), 1, false)
    ln382 := l2, lb382 := lb2

    [l3, lb3] = drawFibLine(fib500, "50%", color.new(color.white, 20), 2, false)
    ln500 := l3, lb500 := lb3

    [l4, lb4] = drawFibLine(fib618, "61.8%", color.new(color.white, 10), 2, false)
    ln618 := l4, lb618 := lb4

    [l5, lb5] = drawFibLine(fib786, "78.6%", color.new(color.white, 60), 1, false)
    ln786 := l5, lb786 := lb5

    if not na(ext127)
        [le1, lbe1] = drawFibLine(ext127, "127.2%", color.new(color.white, 50), 1, true)
        lnE127 := le1, lbE127 := lbe1
    if not na(ext162)
        [le2, lbe2] = drawFibLine(ext162, "161.8%", color.new(color.white, 50), 1, true)
        lnE162 := le2, lbE162 := lbe2

// HTF fib lines (dotted, yellow-ish)
if showHTF and redraw and htfValid
    line.delete(lnHTF382), label.delete(lbHTF382)
    line.delete(lnHTF500), label.delete(lbHTF500)
    line.delete(lnHTF618), label.delete(lbHTF618)

    htfTF = timeframe.isintraday ? "D" : "W"
    [lh1, lbh1] = drawFibLine(htf382, htfTF + " 38.2%", color.new(color.yellow, 30), 1, true)
    lnHTF382 := lh1, lbHTF382 := lbh1
    [lh2, lbh2] = drawFibLine(htf500, htfTF + " 50%", color.new(color.yellow, 30), 1, true)
    lnHTF500 := lh2, lbHTF500 := lbh2
    [lh3, lbh3] = drawFibLine(htf618, htfTF + " 61.8%", color.new(color.yellow, 30), 1, true)
    lnHTF618 := lh3, lbHTF618 := lbh3

// =============================================================================
// VISUALS — BUY / SELL LABELS
// =============================================================================

if showSignals and goLong
    label.new(bar_index, low, "BUY", style=label.style_label_up, color=color.new(color.blue, 10), textcolor=color.white, size=size.normal)

if showSignals and goShort
    label.new(bar_index, high, "SELL", style=label.style_label_down, color=color.new(color.orange, 10), textcolor=color.white, size=size.normal)

bgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : strategy.position_size < 0 ? color.new(color.red, 95) : na)

// =============================================================================
// DASHBOARD (off by default — toggle on for full info)
// =============================================================================

dSz = dashSize == "tiny" ? size.tiny : dashSize == "small" ? size.small : dashSize == "large" ? size.large : size.normal
dSzH = dashSize == "tiny" ? size.small : dashSize == "small" ? size.normal : dashSize == "large" ? size.huge : size.large

if showDashboard and barstate.islast
    var table dash = table.new(position.top_right, 2, 19, bgcolor=color.new(#1a1a2e, 10), border_width=1, border_color=color.new(#16213e, 10), frame_width=3, frame_color=color.new(#0f3460, 10))

    table.cell(dash, 0, 0, "  FibAlgo  ", text_color=color.white, text_size=dSzH, bgcolor=color.new(#0f3460, 0))
    table.cell(dash, 1, 0, "  STRATEGY  ", text_color=color.white, text_size=dSzH, bgcolor=color.new(#0f3460, 0))

    table.cell(dash, 0, 1, "Conviction", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 1, str.tostring(convPct, "#") + "% " + convDir, text_color=convCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    string dir = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : isBull ? "Bullish" : isBear ? "Bearish" : "Neutral"
    color dirCol = (strategy.position_size > 0 or isBull) ? color.green : (strategy.position_size < 0 or isBear) ? color.red : color.gray
    table.cell(dash, 0, 2, "Direction", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 2, dir, text_color=dirCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    color rsCol = not na(rsRank) and rsRank > 70 ? color.green : not na(rsRank) and rsRank > 30 ? color.yellow : color.red
    table.cell(dash, 0, 3, "RS Rank", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 3, not na(rsRank) ? str.tostring(rsRank, "#.#") : "—", text_color=rsCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 4, "Price", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 4, str.tostring(close, format.mintick), text_color=color.white, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    float currentQty = strategy.position_size != 0 ? math.abs(strategy.position_size) : isBull and not na(longSL) and (close - longSL) > 0 ? math.max(1, math.floor(maxLossDollars / (close - longSL))) : isBear and not na(shortSL) and (shortSL - close) > 0 ? math.max(1, math.floor(maxLossDollars / (shortSL - close))) : na
    table.cell(dash, 0, 5, "Qty (auto)", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 5, not na(currentQty) ? str.tostring(currentQty, "#") : "—", text_color=color.white, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 6, "Max Loss", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 6, "$ " + str.tostring(maxLossDollars, "#"), text_color=color.red, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 7, "SL Long", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 7, not na(longSL) ? str.tostring(longSL, format.mintick) : "—", text_color=color.white, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 8, "SL Short", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 8, not na(shortSL) ? str.tostring(shortSL, format.mintick) : "—", text_color=color.white, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    float dTP1 = isBull ? longTP1 : shortTP1
    float dTP2 = isBull ? longTP2 : shortTP2
    table.cell(dash, 0, 9, "TP1 / TP2", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    t1s = not na(dTP1) ? str.tostring(dTP1, format.mintick) : "—"
    t2s = not na(dTP2) ? str.tostring(dTP2, format.mintick) : "—"
    table.cell(dash, 1, 9, t1s + " / " + t2s, text_color=color.green, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    float dispRR = na
    if isBull and not na(longTP1) and not na(longSL) and (close - longSL) > 0
        dispRR := (longTP1 - close) / (close - longSL)
    if isBear and not na(shortTP1) and not na(shortSL) and (shortSL - close) > 0
        dispRR := (close - shortTP1) / (shortSL - close)
    table.cell(dash, 0, 10, "R:R", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 10, not na(dispRR) and dispRR > 0 ? str.tostring(dispRR, "#.##") + " : 1" : "—", text_color=color.yellow, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 11, "AVWAP 52WH", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 11, not na(avwap52) ? str.tostring(avwap52, format.mintick) : "—", text_color=color.purple, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 12, "ATR %", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 12, not na(atrPct) ? str.tostring(atrPct, "#.##") + "%" : "—", text_color=color.yellow, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 13, "Pivot", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 13, str.tostring(actualPivotLen) + (autoPivot ? " (auto)" : ""), text_color=color.white, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    color adxCol = isTrending ? color.green : color.red
    table.cell(dash, 0, 14, "ADX", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 14, str.tostring(adxVal, "#.#") + (isTrending ? " ✓" : " ✗"), text_color=adxCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    string divTxt = bullDivergence ? "Bull Div" : bearDivergence ? "Bear Div" : "None"
    color divCol = bullDivergence ? color.green : bearDivergence ? color.red : color.gray
    table.cell(dash, 0, 15, "RSI Div", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 15, divTxt, text_color=divCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    table.cell(dash, 0, 16, "Pattern", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 16, patternName, text_color=color.white, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    string sectorTxt = sectorBull ? "Bullish" : sectorBear ? "Bearish" : "Neutral"
    color sectorCol = sectorBull ? color.green : sectorBear ? color.red : color.gray
    table.cell(dash, 0, 17, "Sector", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 17, sectorTxt, text_color=sectorCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))

    string sigStat = goLong ? (ema21BounceLong ? "BUY (EMA)" : "BUY SIGNAL") : goShort ? (ema21BounceShort ? "SELL (EMA)" : "SELL SIGNAL") : "Waiting"
    color sigCol = goLong ? color.green : goShort ? color.red : color.gray
    table.cell(dash, 0, 18, "Signal", text_color=color.new(color.white, 30), text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
    table.cell(dash, 1, 18, sigStat, text_color=sigCol, text_size=dSz, bgcolor=color.new(#1a1a2e, 0))
